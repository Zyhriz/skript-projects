# CREDIT GOES TO @zyhriz ON TIKTOK
# github.com/Zyhriz/skript-projects/


options:
	lehmer-seed: 65537 # The default seed. Can be modified by passing a number in the function

	
	# Only change these if you know what you're doing
	lehmer-a: 16807
	lehmer-m: 2147483647

# map() function in processing; maps a number from one range to another
function map(n: number, orgfrom: number, orgto: number, newfrom: number, newto: number) :: number:
	set {_r} to ({_n} - {_orgfrom}) / ({_orgto} - {_orgfrom}) * ({_newto} - {_newfrom}) + {_newfrom}
	return {_r}

#levenshtein distance. returns the amount of insertions, deletions, or substitutions needed to convert one string to another
function lev(a: string, b: string) :: number:
	set {_la} to length of {_a}
	set {_lb} to length of {_b}
	set {_taila} to subtext of {_a} from character 2 to character {_la}
	set {_tailb} to subtext of {_b} from character 2 to character {_lb}
	if {_lb} = 0:
		return {_la}
	if {_la} = 0:
		return {_lb}
	if character 1 of {_a} = character 1 of {_b}:
		return lev({_taila}, {_tailb})
	return 1 + min(lev({_taila}, {_b}), lev({_a}, {_tailb}), lev({_taila}, {_tailb}))

#hamming distance. returns the number of characters different between 2 strings *of the same length*
#returns -1 if the strings are of different size
function hamming(a: string, b: string) :: integer:
	if length of {_a} isn't length of {_b}:
		return -1
	set {_a::*} to split {_a} at ""
	set {_b::*} to split {_b} at ""
	loop size of {_a} times:
		{_a::%loop-number%} = {_b::%loop-number%}
		add 1 to {_r}
	return {_r}

#jaro similarity, or jaro-winkler distance. returns the similarity of 2 strings.
#1 = exact match. 0 = no similarity.
function jaro(a: string, b: string) :: number:
	set {_al} to length of {_a}
	set {_bl} to length of {_b}
	set {_restriction} to floor(max({_al}, {_bl})/2) - 1
	set {_a::*} to split {_a} at ""
	set {_b::*} to split {_b} at ""
	loop {_al} times:
		set {_minrange} to max(1, loop-number - {_restriction})
		set {_maxrange} to loop-number + {_restriction}
		loop integers between {_minrange} and {_maxrange}:
			set {_i} to loop-number-2
			{_a::%loop-number-1%} = {_b::%{_i}%}
			add 1 to {_m} # matching characters
			if {_i} doesn't equal loop-number-1:
				add 1 to {_t} # transpositions
	if {_m} = 0:
		return 0
	set {_r} to (({_m}/{_al})+({_m}/{_bl})+(({_m}-{_t})/{_m}))/3
	return {_r}
		

	# m = number of similar letters

# lehmer random number algorithm. input a seed and it outputs a number
function lehmer(seed: number = {@lehmer-seed}):
	set {_r} to mod(lehmer({_seed} - 1)*{@lehmer-a}, {@lehmer-m})
	return {_r}
# a modified lehmer algorithm that isn't recursive. only use this if you're really limited on storage.
function fast_lehmer(seed: number = {@lehmer-seed}):
	set {_r} to mod({_seed}*{@lehmer-a}, {@lehmer-m})/{@lehmer-m}
	return {_r}

# returns all indices of a string within another
function str_all_indicies(tree: string, forest: string) :: integers:
	loop (size of {_forest} - size of {_tree}) times:
		if subtext of {_forest} from character loop-number to character (loop-number + size of {_tree}) = {_tree}:
			add loop-number to {_indices::*}
	return {_indices::*}

# returns all indices of an object within a list.
function lst_all_indices(tree: object, forest: objects) :: objects:
	loop indices of {_forest}:
		if {_forest::%loop-value%} = {_tree}:
			add loop-value to {_indices::*}
	return {_indices::*}

# GENERAL MATH FUNCTIONS

# self explanatory; returns true if the number is prime
function is_prime(n: integer) :: boolean:
	if {_n} is less than 0:
		return true
	loop {_n} - 2 times:
		mod({_n}, {_n} - loop-number) = 0
		return false
	return true

# self explanatory; returns the factorial of the number
function factorial(n: integer) :: integer:
	if {_n} < 2:
		return {_n}
	return {_n} * factorial({_n} - 1)

# returns the tetrated "a" "n" times; a^^n.
function tetration(a: number, n: integer) :: number:
	if {_n} < 0:
		return NaN value # [Check]
	if {_n} = 0:
		return 1
	set {_r} to {_a} ^ tetration({_a}, {_n} - 1)
	return {_r}